For this project, a custom PCB was designed in KiCad to integrate all necessary components for robot control. The board is centered around an ESP32-WROOM-32 microcontroller module, which handles firmware execution and communication with ROS2 nodes via WiFi or serial interface.
The power supply section includes a buck converter that steps down the 12V battery voltage to 5V for the ESC and servo motor, along with a 3.3V LDO regulator (AMS1117) for the ESP32. The input is protected with reverse polarity protection and filtering capacitors. TVS diodes are placed on critical lines for overvoltage and ESD protection.
The PCB features clearly labeled connectors: a 3-pin header for the ESC (GND, +5V, Signal), a 3-pin header for the servo motor (GND, +5V, PWM), and a USB connector for programming and serial communication via a CP2102 USB-to-Serial bridge. Optionally, the board can include a CAN transceiver (TJA1050) if CAN bus communication is preferred over serial.
This project implements a ROS2-based control system for a robotic car where movement is controlled from a joystick. A ROS2 node running on the computer reads joystick input and converts it into movement commands such as forward, backward, speed, and steering angle. These commands are published as ROS2 messages and received by a second ROS2 node responsible for communication with the robotâ€™s firmware. The firmware runs on a microcontroller (for example ESP32 or STM32), which interprets the received commands and generates control signals for the motors. The propulsion of the robot is achieved with a BLDC motor connected through an ESC, while steering is performed using a servo motor controlled by PWM. In practice, the pipeline works as follows: the user moves the joystick, the first ROS2 node reads the input and publishes the command to a topic, the motor-control ROS2 node subscribes to that topic and forwards the processed command to the microcontroller through serial or CAN communication, and the firmware outputs the appropriate PWM and throttle signals to the ESC and the servo motor. With this architecture, the robot car becomes responsive to joystick input, allowing smooth acceleration, braking, and steering. The project cleanly separates high-level control (ROS2) from low-level execution (firmware driving the motors), making the system modular, debuggable, and easy to extend.
