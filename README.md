For this project, a custom PCB was designed in KiCad to integrate all necessary components for robot control. It implements a ROS2-based control system for a robotic car where movement is controlled from a joystick. The system architecture consists of multiple interconnected ROS2 nodes that form a complete control pipeline from user input to motor actuation. The joystick node runs on the host computer and continuously reads input from a USB or Bluetooth joystick device. It processes the raw joystick axes and button states, mapping them to meaningful robot commands such as forward/backward direction, speed control, steering angle, and emergency stop. These processed commands are published as custom ROS2 messages to dedicated topics like /cmd_vel or /robot_control. The motor control node acts as the bridge between high-level ROS2 commands and low-level firmware execution. It subscribes to the command topics published by the joystick node, receives the movement instructions, and translates them into a format suitable for transmission to the microcontroller. This node handles UART serial communication and formats data packets containing speed, direction, steering angle, and control flags. It continuously monitors the serial connection, handles timeouts, and implements safety features such as command rate limiting and validation. The firmware runs on an Arduino Nano microcontroller and serves as the low-level execution layer. It listens for incoming command packets via the UART serial interface, parses them, and immediately translates the high-level commands into hardware control signals. For propulsion, the firmware controls the BLDC motor by generating appropriate control signals based on the received speed and direction commands. For steering, it outputs a PWM signal to the servo motor, converting the steering angle command into the corresponding servo position. The firmware also implements safety mechanisms such as watchdog timers that detect communication loss and automatically stop the motors if no commands are received within a timeout period. The complete data flow works as follows: the user moves the joystick, the joystick node reads the hardware input and publishes ROS2 messages with speed, direction, and steering commands, the motor control node subscribes to these messages, processes them, and transmits formatted data packets to the Arduino Nano via UART serial, the firmware receives and parses the packets, then immediately outputs control signals to the BLDC motor and PWM signals to the servo motor, and the robot accelerates, brakes, and steers in real time according to joystick input. This architecture cleanly separates concerns: the joystick node handles human interface, the motor control node manages communication and protocol translation, and the firmware executes low-level hardware control. The system is modular and extensible, as additional ROS2 nodes can be added for telemetry visualization, autonomous navigation, or sensor fusion without modifying the existing control pipeline. The use of ROS2's publish-subscribe pattern ensures loose coupling between components, making the system easy to debug, test, and scale. For hardware integration, a custom PCB was designed in KiCad featuring the Arduino Nano, power regulation circuitry, and clearly labeled connectors for the BLDC motor and servo motor.
